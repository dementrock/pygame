class: pygame.physics.world

class world(object)
	####################
	# methods

	def _init_(self)
	
	def add_body(body)  #return body id
	def remove_body(body)
	
	def add_joint(joint) #return joint id
	def remove_joint(joint)
	
	def update() #return collision bodies list
	#####################
	#properties
	
	self.total_update_time
	self.since_last_update_time
	
	
class: pygame.physics.body

class body(object)
	####################
	# methods

	def _init_(self)


	#####################
	#properties
	
	self.mass
	self.shape
	self.position
	self.angle
	self.force
	self.torque
	self.linear_damping
	self.angle_damping
	self.resist         # surface property, for collision response by equation : sum(m*v) = -mul(resist)*sum(m*v')
	
	self.is_static
	self.user_data   # user defined other game data
	
	

	
class pygame.physics.joint.joint_base
(Here I want to explain why I design like this: it's an abstract class, users can write their own joint class by inheriting it, the world maintain joint list inside. Box2d also uses this way)


class joint_base(object) 
	
	####################
	# methods
	def  _init_(self)
	def  _init_(self, from, to)

	#####################
	#properties
	
	self.from_body
	self.to_body
	self.is_collide_connected
	self.user_data   # user defined other game data
	
example joint: distance joint

class pygame.physics.joint.joint_distance

class joint_distance(joint)
	####################
	# methods
	def  _init_(self)
	def  _init_(self, from, to)

	#####################
	#properties
	self.local_anchor1
	self.local_anchor2
	self.length
	
example code:

	joint = new joint_distance(body1,body2)
	joint.local_anchor1 = new vector2(0,0)
	joint.local_anchor2 = new vector2(0,0)
	joint.length = 10
	world.add_joint(joint)
	
	
##############################
# classes for basic physics functions
module : pygame.physics.basic
	
class aabb_box:
    def collision_with(obb_box):

class obb_box:
    def collision_with(obb_box):
    
    
class shape:
    def get_aabb_box():
    def get_obb_box():

class Polygon(Shape) # override base functions
class Circle(Shape) # override base functions


###############################
# Math classes 

(Maybe it needs redesigned or we can use a exist python vector math library)

module : pygame.physics.math

class vector2
	self.x
	self.y
	self.z
	
	def _init_(self)
	def _init_(self,x,y,z)
	
class matrix2x2
	self.x11
	self.x12
	self.x21
	self.x22
	
	def _init_(self)
	
def add_vector2(vec1,vec2) # result = vec1 + vec2
def sub_vector2(vec1,vec2) # result = vec1 - vec2
def dot_vector2(vec1,vec2) # result = vec1 dot vec2  (result is a scalar)
def cross_vector2(vec1,vec2) # result = vec1 cross vec2 (result is a vector)

def add_matrix2x2(mat1,mat2)
def sub_matrix2x2(mat1,mat2)
def mul_matrix2x2(mat1,mat2)
def mul_matrix2x2_vector2(mat,vec) # result = mat * vec  (result is a vec) , for transform and rotation



2. pygame higher render module

class physics_sprite(SomeKindOfSprite):
    self.body  #Class Body
    def update(self, Surface):
        #do phy updates

    def _init_(self, PhyGroup):
    # here PhyGroup derive from Group
    #or
    #def _init_(self, group)
    
    
class physics_group(group)
    #physics render here
    def update(self)
    def _init(self)
def phycollision(group,group)
