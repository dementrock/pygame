<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module SYSTEM "api.dtd">

<module name="pygame2.sdl.video">
  <short>SDL video display wrapper module.</short>
  <desc>SDL video display wrapper module.</desc>

  <class name="Overlay">
    <constructor>Overlay (surface, width, height, format) -> Overlay
      Overlay (surface, size, format) -> Overlay
    </constructor>
    <desc>
      Creates a new Overlay for a surface.
      
      The Overlay objects provide support for accessing hardware video overlays.
      Video overlays do not use standard RGB pixel formats, and can use
      multiple resolutions of data to create a single image.
      
      The Overlay objects represent lower level access to the display hardware.
      To use the object you should understand the technical details of video
      overlays.

      The Overlay format determines the type of pixel data used. Not all
      hardware will support all types of overlay formats. Supported format
      types are

      * YV12_OVERLAY
      * IYUV_OVERLAY
      * YUV2_OVERLAY
      * UYVY_OVERLAY
      * YVYU_OVERLAY

      The width and height arguments control the size for the overlay image
      data. The overlay image can be displayed at any size, not just the
      resolution of the overlay and are always visible, and always show above
      the regular display contents.
    </desc>
    <method name="display">
      <call>display ([rect]) -> None</call>
      <desc>
        Displays the current overlay data in the SDL overlay plane.
      </desc>
    </method>
    <attr name="format"><desc>Gets the format of the Overlay.</desc></attr>
    <attr name="h"><desc>Gets the height of the Overlay.</desc></attr>
    <attr name="height"><desc>Gets the height of the Overlay.</desc></attr>
    <attr name="hw_overlay">
      <desc>Gets, whether the Overlay is hardware accelerated.</desc>
    </attr>
    <method name="lock">
      <call>lock () -> None</call>
      <desc>
        Locks the Overlay for a direct access to its internal pixel data.
      </desc>
    </method>
    <attr name="locked">
      <desc>Gets, whether the Overlay is currently locked.</desc>
    </attr>
    <attr name="pitches">
      <desc>Gets the pitches (length in bytes) for all planes of the
      Overlay.</desc>
    </attr>
    <attr name="pixels">
      <desc>Gets the pixel buffers for all planes of the
      Overlay.</desc>
    </attr>
    <attr name="planes">
      <desc>Get the amount of planes for the Overlay.</desc>
    </attr>
    <attr name="size">
      <desc>Gets the width and height of the Overlay.</desc>
    </attr>
    <method name="unlock">
      <call>unlock () -> None</call>
      <desc>
        Unlocks the Overlay, releasing the direct access to the pixel data.
      </desc>
    </method>
    <attr name="w"><desc>Gets the width of the Overlay.</desc></attr>
    <attr name="width"><desc>Gets the width of the Overlay.</desc></attr>
  </class>

  <class name="PixelFormat">
    <constructor>PixelFormat () -> PixelFormat</constructor>
    <desc>
      Creates a new, empty PixelFormat.
      
      TODO
    </desc>
    <attr name="alpha">
      <desc>Gets or sets the overall surface alpha value in the
      range [0, 255].</desc>
    </attr>
    <attr name="bits_per_pixel">
      <desc>Gets or sets the bits per pixel to use for
      storing a RGBA value.</desc>
    </attr>
    <attr name="bytes_per_pixel">
      <desc>Gets or sets the bytes per pixel to use for
      storing a RGBA value.</desc>
    </attr>
    <attr name="colorkey">
      <desc>Gets or sets the RGBA value of transparent pixels.</desc>
    </attr>
    <method name="get_rgba">
      <call>get_rgba (color) -> int, int, int, int</call>
      <desc>
        Gets the RGBA values for the color.

        Gets the single RGBA values for a color value, which fit the
        PixelFormat best. This means that an internal conversion is done
        on demand to match the passed color to the PixelFormat's
        supported value ranges. If the PixelFormat does not have alpha
        transparency support, the last RGBA integer will be set to fully
        opaque (255).
      </desc>
    </method>
    <attr name="losses">
      <desc>Gets or sets the precision loss of each RGBA color
      component.</desc>
    </attr>
    <method name="map_rgba">
      <call>map_rgba (r, g, b[, a]) -> Color
        map_rgba (color) -> Color
      </call>
      <desc>
        Converts a color to the best value matching the format.
        
        TODO
      </desc>
    </method>
    <attr name="masks">
      <desc>Gets or sets the binary mask used to retrieve individual
      color values.</desc>
    </attr>
    <attr name="palette">
      <desc>Gets the color palette (if any) used by the
      PixelFormat. If the PixelFormat does not have any palette, None will be
      returned.</desc>
    </attr>
    <attr name="readonly">
      <desc>Gets, whether the PixelFormat is read-only (cannot be
      changed).</desc>
    </attr>
    <attr name="shifts">
      <desc>Gets the binary left shift of each color component in
      the pixel value.</desc>
    </attr>
  </class>

  <class name="Surface">
    <constructor>Surface (width, height[, depth, flags, masks]) -> Surface
      Surface (size[, depth, flags, masks]) -> Surface
    </constructor>
    <desc>
      Creates a new Surface to represent images.
      
      TODO
    </desc>
    <method name="blit">
      <call>blit (srcsurface[, destrect, srcrect, blendargs]) -> Rect</call>
      <desc>
        Draws the passed source surface onto this surface.
        
        Draws the passed source surface onto this surface. The dstrect and
        srcrect arguments are used for clipping the destionation area (on this
        surface) and source area (on the source surface). For the destination 
        rectangle, the width and height are ignored, only the position is taken
        into account. For the source rectangle, all values, position as well as
        the size are used for clipping.
        
        The optional blending arguments for the drawing operation perform
        certain specialised pixel manipulations. For those, pixels on the same
        position are evaluated and the result manipulated according to the
        argument.
        
        +---------------------------+-----------------------------------------+
        | Blend type                | Effect                                  |
        +===========================+=========================================+
        | BLEND_RGB_ADD             | The sum of both pixel values will be    |
        |                           | set as resulting pixel.                 |
        +---------------------------+-----------------------------------------+
        | BLEND_RGB_SUB             | The difference of both pixel values     |
        |                           | will be set as resulting pixel.         |
        +---------------------------+-----------------------------------------+
        | BLEND_RGB_MIN             | The minimum of each R, G and B channel  |
        |                           | of the pixels will be set as result.    |
        +---------------------------+-----------------------------------------+
        | BLEND_RGB_MAX             | The maximum of each R, G and B channel  |
        |                           | of the pixels will be set as result.    |
        +---------------------------+-----------------------------------------+
        | BLEND_RGB_MULT            | The result of a multiplication of both  |
        |                           | pixel values will be used.              |
        +---------------------------+-----------------------------------------+
        
        The BLEND_RGB_*** flags do not take the alpha channel into account and
        thus are much faster for most blit operations without alpha
        transparency. Whenever alpha transparency has to be taken into account,
        the blending flags below should be used.
        
        +---------------------------+-----------------------------------------+
        | Blend type                | Effect                                  |
        +===========================+=========================================+
        | BLEND_RGBA_ADD            | The sum of both pixel values will be    |
        |                           | set as resulting pixel.                 |
        +---------------------------+-----------------------------------------+
        | BLEND_RGBA_SUB            | The difference of both pixel values     |
        |                           | will be set as resulting pixel.         |
        +---------------------------+-----------------------------------------+
        | BLEND_RGBA_MIN            | The minimum of each R, G, B and A       |
        |                           | channel of the pixels will be set as    |
        |                           | result.                                 |
        +---------------------------+-----------------------------------------+
        | BLEND_RGBA_MAX            | The maximum of each R, G, B and A       |
        |                           | channel of the pixels will be set as    |
        |                           | result.                                 |
        +---------------------------+-----------------------------------------+
        | BLEND_RGBA_MULT           | The result of a multiplication of both  |
        |                           | pixel values will be used.              |
        +---------------------------+-----------------------------------------+
      </desc>
    </method>
    <attr name="clip_rect">
      <desc>Gets or sets the current clipping rectangle for
      operations on the Surface.</desc>
    </attr>
    <method name="copy">
      <call>copy () -> Surface </call>
      <desc>
        Creates an exact copy of the Surface and its image data.
      </desc>
    </method>
    <method name="convert">
      <call>convert ([pixelformat, flags]) -> Surface</call>
      <desc>
        Converts the Surface to the desired pixel format.
        
        Converts the Surface to the desired pixel format. If no format is
        given, the active display format is used, which will be the fastest for
        blit operations to the screen. The flags are the same as for surface
        creation.
        
        This creates a new, converted surface and leaves the original one
        untouched.
      </desc>
    </method>
    <method name="fill">
      <call>fill (color[, dstrect, blendargs]) -> None</call>
      <desc>
        Fills the Surface with a color.
        
        Fills the Surface with the desired color. The color does not need to
        match the Surface's format, it will be converted implicitly to the
        nearest appropriate color for its format.
        
        The optional destination rectangle limits the color fill to the
        specified area. The blendargs are the same as for the :meth:`blit`
        operation, but compare the color with the specific Surface pixel value.
      </desc>
    </method>
    <attr name="flags">
      <desc>The currently set flags for the Surface.</desc>
    </attr>
    <method name="flip">
      <call>flip () -> None</call>
      <desc>
        Swaps the screen buffers for the Surface.
        
        Swaps screen buffers for the Surface, causing a full update and redraw
        of its whole area.  
      </desc>
    </method>
    <attr name="format">
      <desc>Gets the (read-only)
      :class:`pygame2.sdl.video.PixelFormat` for this Surface.</desc>
    </attr>
    <method name="get_alpha">
      <call>get_alpha () -> int</call>
      <desc>
        Gets the current overall alpha value of the Surface.
        
        Gets the current overall alpha value of the Surface. In case the
        surface does not support alpha transparency (SRCALPHA flag not set),
        None will be returned.
      </desc>
    </method>
    <method name="get_at">
      <call>get_at (x, y) -> Color
        get_at (point) -> Color
      </call>
      <desc>
        Gets the Surface pixel value at the specified point.
      </desc>
    </method>
    <method name="get_colorkey">
      <call>get_colorkey () -> Color</call>
      <desc>
        Gets the colorkey for the Surface.
        
        Gets the colorkey for the Surface or None in case it has no colorkey
        (SRCCOLORKEY flag not set).
      </desc>
    </method>
    <method name="get_palette">
      <call>get_palette () -> (Color, Color, ...)</call>
      <desc></desc>
    </method>
    <attr name="h"><desc>Gets the height of the Surface.</desc></attr>
    <attr name="height"><desc>Gets the height of the Surface.</desc></attr>
    <method name="lock">
      <call>lock () -> None</call>
      <desc>
        Locks the Surface for a direct access to its internal pixel data.
      </desc>
    </method>
    <attr name="locked">
      <desc>Gets, whether the Surface is currently locked.</desc>
    </attr>
    <attr name="pitch">
      <desc>Get the length of a surface scanline in bytes.</desc>
    </attr>
    <attr name="pixels">
      <desc>Gets the pixel buffer of the Surface.</desc>
    </attr>
    <method name="save">
      <call>save (file[, type]) -> None</call>
      <desc>
        Saves the Surface to a file.

        Saves the Surface to a file. The file argument can be either a
        file name or a file-like object to save the Surface to. The
        optional type argument is required, if the file type cannot be
        determined by the suffix.

        Currently supported file types (suitable to pass as string for
        the type argument) are:
        
        * BMP
        * TGA
        * PNG
        * JPEG (JPG)

        If no type information is supplied and the file type cannot be
        determined either, it will use TGA.
      </desc>
    </method>
    <method name="set_alpha">
      <call>set_alpha (alpha[, flags]) -> None</call>
      <desc>
        Adjusts the alpha properties of the Surface.
        
        TODO
      </desc>
    </method>
    <method name="set_at">
      <call>set_at (x, y, color) -> None
      set_at (point, color) -> None
      </call>
      <desc>
        Sets the Surface pixel value at the specified point.
      </desc>
    </method>
    <method name="set_colorkey">
      <call>set_colorkey (colorkey[, flags]) -> None</call>
      <desc>
        Adjusts the colorkey of the Surface.
        
        TODO
      </desc>
    </method>
    <method name="set_colors">
      <call>set_colors ((color1, color2, ...)[, first]) -> bool</call>
      <desc>
        Sets a portion of the colormap palette for the 8-bit Surface.

        Sets a portion of the colormap palette for the 8-bit Surface,
        starting at the desired first position. If the first position
        plus length of the passed colormap exceeds the Surface palette
        size, the palette will be unchanged and False returned.

        If any other error occurs, False will be returned and the
        Surface palette should be inspected for any changes.
      </desc>
    </method>
    <method name="set_palette">
      <call>set_palette ((color1, color2, ...), flags[, first]) -> bool</call>
      <desc>
        Sets a portion of the palette for the given 8-bit surface.

        Sets a portion of the color palette for the 8-bit Surface,
        starting at the desired first position. If the first position
        plus length of the passed colormap exceeds the Surface palette
        size, the palette will be unchanged and False returned.

        If any other error occurs, False will be returned and the
        Surface palette should be inspected for any changes.
      </desc>
    </method>
    <attr name="size">
      <desc>Gets the size of the Surface.</desc>
    </attr>
    <method name="unlock">
      <call>unlock () -> None</call>
      <desc>
        Unlocks the Surface, releasing the direct access to the pixel data.
      </desc>
    </method>
    <method name="update">
      <call>update ([rect]) -> None
      update ([(rect1, rect2, ...)]) -> None</call>
      <desc>
        Updates the given area on the Surface.

        Upates the given area (or areas, if a list of rects is passed)
        on the Surface.
      </desc>
    </method>
    <attr name="w"><desc>Gets the width of the Surface.</desc></attr>
    <attr name="width"><desc>Gets the width of the Surface.</desc></attr>
  </class>

  <func name="get_drivername">
    <call>get_drivername () -> str</call>
    <desc>
      Gets the name of the video driver.
      
      Gets the name of the video driver or None, if the video system has
      not been initialised or it could not be determined.
    </desc>
  </func>
  <func name="get_gammaramp">
    <call>get_gammaramp () -> (int, int, ...), (int, int, ...), (int, int, ...)
    </call>
    <desc>
      Gets the color gamma lookup tables for the display.

      Gets the color gamma lookup table for the display. This will
      return three tuples for the red, green and blue gamma values. Each
      tuple contains 256 values.
    </desc>
  </func>
  <func name="get_info">
    <call>get_info () -> dict</call>
    <desc>
      Gets information about the video hardware.

      Gets information about the video hardware. The returned dictionary
      contains the following entries.

      +------------------------+---------------------------------------------+
      | Entry                  | Meaning                                     |
      +========================+=============================================+
      | hw_available           | Is it possible to create hardware surfaces? |
      +------------------------+---------------------------------------------+
      | wm_available           | Is a window manager available?              |
      +------------------------+---------------------------------------------+
      | blit_hw                | Are hardware to hardware blits accelerated? |
      +------------------------+---------------------------------------------+
      | blit_hw_CC             | Are hardware to hardware colorkey blits     |
      |                        | accelerated?                                |
      +------------------------+---------------------------------------------+
      | blit_hw_A              | Are hardware to hardware alpha blits        |
      |                        | accelerated?                                |
      +------------------------+---------------------------------------------+
      | blit_sw                | Are software to hardware blits accelerated? |
      +------------------------+---------------------------------------------+
      | blit_sw_CC             | Are software to hardware colorkey blits     |
      |                        | accelerated?                                |
      +------------------------+---------------------------------------------+
      | blit_sw_A              | Are software to hardware alpha blits        |
      |                        | accelerated?                                |
      +------------------------+---------------------------------------------+
      | blit_fill              | Are color fills accelerated?                |
      +------------------------+---------------------------------------------+
      | video_mem              | Total amount of video memory in Kilobytes   |
      +------------------------+---------------------------------------------+
      | vfmt                   | Pixel format of the video device            |
      +------------------------+---------------------------------------------+
    </desc>
  </func>
  <func name="get_videosurface">
    <call>get_videosurface () -> Surface</call>
    <desc>
      Gets the current display surface or None, if there is no such Surface.
    </desc>
  </func>
  <func name="init">
    <call>init () -> None</call>
    <desc>
      Initializes the video subsystem of the SDL library.
    </desc>
  </func>
  <func name="is_mode_ok">
    <call>is_mode_ok (width, height[, bpp, flags]) -> bool
    is_mode_ok (size[, bpp, flags]) -> bool
    </call>
    <desc>
      Checks, whether the requested video mode is supported.

      Checks, whether the video mode is supported for the passed size,
      bit depth and flags. If the bit depth (bpp) argument is omitted,
      the current screen bit depth will be used. 
      
      The optional flags argument is the same as for :meth:`set_mode`.
    </desc>
  </func>
  <func name="list_modes">
    <call>list_modes ([, format, flags]) -> [rect, rect, ...]</call>
    <desc>
      Returns the supported modes for a specific format and flags.

      Returns the supported modes for a specific format and flags.
      The optional format argument must be a :class:`PixelFormat`
      instance with the desired mode information. The optional flags
      argument is the same as for :meth:`set_mode`.
      
      If both, the format and flags are omitted, all supported screen
      resolutions for all supported formats and flags are returned.
    </desc>
  </func>
  <func name="quit">
    <call>quit () -> None</call>
    <desc>
      Shuts down the video subsystem of the SDL library.

      After calling this function, you should not invoke any class,
      method or function related to the video subsystem as they are
      likely to fail or might give unpredictable results.
    </desc>
  </func>
  <func name="set_gamma">
    <call>set_gamma (red, green, blue) -> None</call>
    <desc>
      Sets the gamma values for all three color channels.
      
      Sets the gamma values for all three color channels. In case
      adjusting the gamma is not supported, an exception will be raised.
    </desc>
  </func>
  <func name="set_gammaramp">
    <call>set_gammaramp (redtable, greentable, bluetable) -> None</call>
    <desc>
      Sets the color gamma lookup tables for the display.

      Sets the color gamma lookup table for the display. The three
      arguments must be sequences with 256 integer value enties for the
      gamma ramps.
    </desc>
  </func>
  <func name="set_mode">
    <call>set_mode (width, height[, bpp, flags]) -> Surface
    set_mode (size[, bpp, flags]) -> Surface
    </call>
    <desc>
      Creates the main display Surface.

      Creates the main display Surface using the specified size, bit
      depth and flags. If the bit depth (bpp) argument is omitted, the
      current screen bit depth will be used.

      The optional flags argument can be a bitwise OR'd combination of
      the constants below.

      +-------------------+-----------------------------------------------+
      | Flag              | Description                                   |
      +===================+===============================================+
      | SWSURFACE         | Create the video surface in system memory     |
      +-------------------+-----------------------------------------------+
      | HWSURFACE         | Create the video surface in video memory      |
      +-------------------+-----------------------------------------------+
      | ASYNCBLIT         | Enables the use of asynchronous updates of    |
      |                   | the display surface. This will usually slow   |
      |                   | down blitting on single CPU machines, but may |
      |                   | provide a speed increase on SMP systems.      |
      +-------------------+-----------------------------------------------+
      | ANYFORMAT         | Normally, if a video surface of the requested |
      |                   | bits-per-pixel (bpp) is not available, SDL    |
      |                   | will emulate one with a shadow surface.       |
      |                   | Passing ANYFORMAT prevents this and causes    |
      |                   | SDL to use the video surface, regardless of   |
      |                   | its pixel depth.                              |
      +-------------------+-----------------------------------------------+
      | HWPALETTE         | Give SDL exclusive palette access. Without    |
      |                   | this flag you may not always get the the      |
      |                   | colors you request with                       |
      |                   | :meth:`Surface.set_colors` or                 |
      |                   | :meth:`Surface.set_palette`.                  |
      +-------------------+-----------------------------------------------+
      | DOUBLEBUF         | Enable hardware double buffering; only valid  |
      |                   | with HWSURFACE. Calling :meth:`Surface.flip`  |
      |                   | will flip the buffers and update the screen.  |
      |                   | All drawing will take place on the surface    |
      |                   | that is not displayed at the moment. If       |
      |                   | double buffering could not be enabled then    |
      |                   | :meth:`Surface.flip` will just perform a      |
      |                   | :meth:`Surface.update` on the entire screen.  |
      +-------------------+-----------------------------------------------+
      | FULLSCREEN        | SDL will attempt to use a fullscreen mode. If |
      |                   | a hardware resolution change is not possible  |
      |                   | (for whatever reason), the next higher        |
      |                   | resolution will be used and the display       |
      |                   | window centered on a black background.        |
      +-------------------+-----------------------------------------------+
      | OPENGL            | Create an OpenGL rendering context. You       |
      |                   | should have previously set OpenGL video       |
      |                   | attributes with                               |
      |                   | :meth:`pygame2.sdl.gl.set_attribute`.         |
      +-------------------+-----------------------------------------------+
      | OPENGLBLIT        | Create an OpenGL rendering context, like      |
      |                   | above, but allow normal blitting operations.  |
      |                   | The screen (2D) surface may have an alpha     |
      |                   | channel, and :meth:`Surface.update` must be   |
      |                   | used for updating changes to the screen       |
      |                   | surface. NOTE: This option is kept for        |
      |                   | compatibility only, and is not recommended    |
      |                   | for new code.                                 |
      +-------------------+-----------------------------------------------+
      | RESIZABLE         | Create a resizable window. When the window is |
      |                   | resized by the user a VIDEORESIZE event is    |
      |                   | generated and :meth:`set_mode` can be called  |
      |                   | again with the new size.                      |
      +-------------------+-----------------------------------------------+
      | NOFRAME           | If possible, NOFRAME causes SDL to create a   |
      |                   | window with no title bar or frame decoration. |
      |                   | Fullscreen modes automatically have this flag |
      |                   | set.                                          |
      +-------------------+-----------------------------------------------+
    </desc>
  </func>
  <func name="was_init">
    <call>was_init () -> bool</call>
    <desc>
      Returns, whether the video subsystem of the SDL library is initialized.
    </desc>
  </func>
</module>

