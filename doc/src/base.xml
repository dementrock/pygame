<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module SYSTEM "api.dtd">

<module name="pygame2.base">
  <show>0</show>
  <alias>pygame2</alias>
  <short>basic features used by pygame2</short>
  <desc>
    Base features for pygame2 that are shared shared and used throughout
    the whole pygame2 package.
  </desc>

  <data name="__version__">
    The version of the Pygame2 package as string.
  </data>

  <data name="version_info">
    The version of the Pygame2 package as value tuple. The tuple is of
    the form ``('major', 'minor', 'micro', 'releaselevel')``, where all
    values except the *releaselevel* are integers.
  </data>

  <class name="BufferProxy">
    <constructor>BufferProxy () -> BufferProxy</constructor>
    <desc>Creates a new, empty :class:`BufferProxy`.

    A buffer interface object that acts as a proxy on classes and
    attributes not featuring the buffer interface. A
    :class:`BufferProxy` usually should be constructed from C code, not
    Python.
    </desc>
    <attr name="length">
      <desc>Gets the size of the buffer data in bytes.</desc>
    </attr>
    <attr name="raw">
      <desc>Gets the raw buffer data as string. The string may contain
      NUL bytes.</desc>
    </attr>
    <method name="write">
      <call>write (buffer, offset) -> None</call>
      <desc>
        Writes raw data to the :class:`BufferProxy`.

        Writes the raw data from buffer to the :class:`BufferProxy` object,
        starting at the specified offset within the :class:`BufferProxy`. If
        the length of the passed buffer exceeds the length of the
        :class:`BufferProxy` (reduced by the offset), an :exc:`IndexError` will
        be raised.
      </desc>
    </method>
  </class>

  <class name="Color">
    <constructor>Color (...) -> Color</constructor>
    <desc>Creates a new :class:`Color` object.

    The :class:`Color` class represents RGBA color values using a value range of
    0-255. It allows basic arithmetic operations to create new colors,
    supports conversions to other color spaces such as HSV or HSL and lets
    you adjust single color channels. The following constructors are supported:
    
    * Color (0xAARRGGBB)
    * Color (0xRRGGBB)
    * Color (r, g, b, a)
    * Color (r, g, b)
    * Color ("0xRRGGBBAA")
    * Color ("#RRGGBBAA")
    * Color ("name")
    </desc>
    <example>
      from pygame2 import Color

      red = Color (255, 0, 0)
      green = Color (0x0000FF00)
      blue = Color ("blue")
    </example>
    <attr name="a">
      <desc>Gets or sets the alpha value of the :class:`Color`.</desc>
    </attr>
    <attr name="b">
      <desc>Gets or sets the blue value of the :class:`Color`.</desc>
    </attr>
    <attr name="cmy">
      <desc>The CMY representation of the :class:`Color`. The CMY
      components are in the ranges C = [0, 1], M = [0, 1], Y = [0,
      1]. Note that this will not return the absolutely exact CMY values
      for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the CMY mapping from 0-1 rounding errors may cause the
      CMY values to differ slightly from what you might expect.</desc>
    </attr>
    <method name="correct_gamma">
      <call>correct_gamma (gamma) -> Color</call>
      <desc>
        Applies a certain gamma value to the :class:`Color`.

        Applies a certain gamma value to the :class:`Color` and returns a new
        :class:`Color` with the adjusted RGBA values.
      </desc>
    </method>
    <attr name="g">
      <desc>Gets or sets the green value of the :class:`Color`.</desc>
    </attr>
    <attr name="hsla">
      <desc>The HSLA representation of the :class:`Color`. The HSLA
      components are in the ranges H = [0, 360], S = [0, 100], L = [0, 100],
      A = [0, 100]. Note that this will not return the absolutely exact HSL
      values for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the HSL mapping from 0-100 and 0-360 rounding errors may cause
      the HSL values to differ slightly from what you might expect.</desc>
    </attr>
    <attr name="hsva">
      <desc>The HSVA representation of the :class:`Color`. The HSVA
      components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100],
      A = [0, 100]. Note that this will not return the absolutely exact HSV
      values for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the HSV mapping from 0-100 and 0-360 rounding errors may cause
      the HSV values todiffer slightly from what you might expect.</desc>
    </attr>
    <attr name="i1i2i3">
      <desc>The I1I2I3 representation of the :class:`Color`.
      The I1I2I3 components are in the ranges I1 = [0, 1], I2 = [-0.5, 0.5],
      I3 = [-0.5, 0.5]. Note that this will not return the absolutely exact
      I1I2I3 values for the set RGB values in all cases. Due to the RGB mapping
      from 0-255 and the I1I2I3 from 0-1 rounding errors may cause the I1I2I3
      values to differ slightly from what you might expect.</desc>
    </attr>
    <method name="normalize">
      <call>normalize() -> tuple</call>
      <desc>
        Returns the normalized RGBA values of the :class:`Color`.

        Returns the normalized RGBA values of the :class:`Color` as floating
        point values.
      </desc>
    </method>
    <attr name="r">
      <desc>Gets or sets the red value of the :class:`Color`.</desc>
    </attr>
  </class>

  <class name="Error">
    <constructor>Error (...) -> Error</constructor>
    <desc>
      A specialized exception class that indicates a misbehaviour within the
      pygame2 modules.
    </desc>
  </class>

  <class name="FRect">
    <constructor>FRect (...) -> FRect</constructor>
    <desc>
      A class for storing rectangular coordinates.

      A :class:`FRect` is used to store and manipulate rectangular coordinates.
    </desc>
    <attr name="bottom">
      <desc>Gets or sets the bottom edge position of the :class:`FRect`.</desc>
    </attr>
    <attr name="bottomleft">
      <desc>Gets or sets the bottom left corner position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="bottomright">
      <desc>Gets or sets the bottom right corner position of the
      :class:`FRect`.</desc>
    </attr>
    <method name="ceil">
      <call>ceil () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified :class:`FRect`.

        This creates a :class:`Rect` using the smallest integral values greater
        or equal to the :class:`FRect` floating point values.
      </desc>
    </method>
    <attr name="center">
      <desc>Gets or sets the center position of the :class:`FRect`.</desc>
    </attr>
    <attr name="centerx">
      <desc>Gets or sets the horizontal center position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="centery">
      <desc>Gets or sets the vertical center position of the
      :class:`FRect`.</desc>
    </attr>
    <method name="clamp">
      <call>clamp (FRect) -> FRect</call>
      <desc>
        Moves the rectangle inside another.

        Returns a new rectangle that is moved to be completely inside
        the argument :class:`FRect`. If the rectangle is too large to
        fit inside, it is centered inside the argument :class:`FRect`,
        but its size is not changed.
      </desc>
    </method>
    <method name="clamp_ip">
      <call>clamp_ip (FRect) -> None</call>
      <desc>
        Moves the rectangle inside another, in place.

        Same as FRect.clamp(FRect), but operates in place.
      </desc>
    </method>
    <method name="clip">
      <call>clip (FRect) -> FRect</call>
      <desc>
        Crops a rectangle inside another.

        Returns a new rectangle that is cropped to be completely inside
        the argument :class:`FRect`. If the two rectangles do not
        overlap to begin with, a :class:`FRect` with 0 size is
        returned. Thus it returns the area, in which both rects overlap.
      </desc>
    </method>
    <method name="collidedict">
      <call>collidedict (dict[, checkvals, key]) -> key, value</call>
      <desc>
        Test if one rectangle in a dictionary intersects.

        Returns the key and value of the first dictionary value that
        collides with the :class:`FRect`. If no collisions are found,
        None is returned. Depending on the *checkvals* argument either the
        keys or values of the dict must be :class:`FRect` objects. By
        default, the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::
        
          def cmpfunc (rect1, rect2):
              ...
              return True

      </desc>
    </method>
    <method name="collidedictall">
      <call>
        collidedictall (dict[, checkvals, key]) -> [(key, value), ...]
      </call>
      <desc>
        Test if all rectangles in a dictionary intersect.

        Returns a list of all the key and value pairs that intersect
        with the :class:`FRect`. If no collisions are found an empty
        list is returned. Depending on the *checkvals* argument either the
        keys or values of the dict must be :class:`FRect` objects. By
        default, the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True

      </desc>
    </method>
    <method name="collidelist">
      <call>collidelist (rects[, key]) -> index</call>
      <desc>
        Test if one rectangle in a list intersects.

        Test whether the rectangle collides with any in a sequence of
        rectangles. The index of the first collision found is
        returned. If no collisions are found an index of -1 is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelistall">
      <call>collidelistall (rects[, key]) -> [index, ...]</call>
      <desc>
        Test if all rectangles in a list intersect.

        Returns a list of all the indices that contain rectangles that
        collide with the :class:`FRect`. If no intersecting rectangles
        are found, an empty list is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidepoint">
      <call>collidepoint (x, y) -> bool</call>
      <desc>
        Test if a point is inside a rectangle.

        Returns true if the given point is inside the rectangle. A point
        along the right or bottom edge is not considered to be inside
        the rectangle.
      </desc>
    </method>
    <method name="colliderect">
      <call>colliderect (FRect) -> bool</call>
      <desc>
        Test if two rectangles overlap.

        Returns true if any portion of either rectangle overlap (except
        the top+bottom or left+right edges).
      </desc>
    </method>
    <method name="contains">
      <call>contains (FRect) -> bool</call>
      <desc>
        Test if one rectangle is inside another.

        Returns true when the argument rectangle is completely inside
        the :class:`FRect`.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> FRect</call>
      <desc>
        Creates a copy of the :class:`FRect`.

        Returns a new :class:`FRect`, that contains the same values as the
        caller.
      </desc>
    </method>
    <method name="fit">
      <call>fit (FRect) -> FRect</call>
      <desc>
        Resize and move a rectangle with aspect ratio.

        Returns a new rectangle that is moved and resized to fit
        another. The aspect ratio of the original :class:`FRect` is
        preserved, so the new rectangle may be smaller than the target
        in either width or height.
      </desc>
    </method>
    <method name="floor">
      <call>floor () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified :class:`FRect`.

        This creates a :class:`Rect` using the largest integral values less than
        or equal to the :class:`FRect` floating point values.
      </desc>
    </method>
    <attr name="h">
      <desc>Gets or sets the height of the :class:`FRect`.</desc>
    </attr>
    <attr name="height">
      <desc>Gets or sets the height of the :class:`FRect`.</desc>
    </attr>
    <method name="inflate">
      <call>inflate (x, y) -> FRect</call>
      <desc>
        Grow or shrink the rectangle size.

        Returns a new rectangle with the size changed by the given
        offset. The rectangle remains centered around its current
        center. Negative values will shrink the rectangle.
      </desc>
    </method>
    <method name="inflate_ip">
      <call>inflate_ip (x, y) -> None</call>
      <desc>
        Grow or shrink the rectangle size, in place.

        Same as FRect.inflate(x, y), but operates in place.
      </desc>
    </method>
    <attr name="left">
      <desc>Gets or sets the left edge position of the :class:`FRect`.</desc>
    </attr>
    <attr name="midbottom">
      <desc>Gets or sets the mid bottom edge position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="midleft">
      <desc>Gets or sets the mid left edge position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="midright">
      <desc>Gets or sets the mid right edge position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="midtop">
      <desc>Gets or sets the mid top edge position of the :class:`FRect`.</desc>
    </attr>
    <method name="move">
      <call>move (x, y) -> FRect</call>
      <desc>
        Moves the rectangle.

        Returns a new rectangle that is moved by the given offset. The x
        and y arguments can be any integer value, positive or negative.
      </desc>
    </method>
    <method name="move_ip">
      <call>move_ip (x, y) -> None</call>
      <desc>
        Moves the rectangle, in place.

        Same as FRect.move (x, y), but operates in place.
      </desc>
    </method>
    <attr name="right">
      <desc>Gets or sets the right position of the :class:`FRect`.</desc>
    </attr>
    <method name="round">
      <call>round () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified :class:`FRect`.

        This creates a :class:`Rect` using the :class:`FRect` floating
        point values rounded to the nearest integral value.
      </desc>
    </method>
    <attr name="size">
      <desc>Gets or sets the width and height of the :class:`FRect` as
      2-value tuple.</desc>
    </attr>
    <attr name="top">
      <desc>Gets or sets the top edge position of the :class:`FRect`.</desc>
    </attr>
    <attr name="topleft">
      <desc>Gets or sets the top left corner position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="topright">
      <desc>Gets or sets the top right corner position of the
      :class:`FRect`.</desc>
    </attr>
    <method name="trunc">
      <call>trunc () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified :class:`FRect`.

        This creates a :class:`Rect` using truncated integral values from the
        :class:`FRect` floating point values.
      </desc>
    </method>
    <method name="union">
      <call>union (FRect) -> FRect</call>
      <desc>
        Joins two rectangles into one.

        Returns a new rectangle that completely covers the area of the
        two provided rectangles. There may be area inside the new :class:`FRect`
        that is not covered by the originals.
      </desc>
    </method>
    <method name="union_ip">
      <call>union_ip (FRect) -> FRect</call>
      <desc>
        Joins two rectangles into one, in place.

        Same as FRect.union(FRect), but operates in place.
      </desc>
    </method>
    <attr name="w">
      <desc>Gets or sets the width of the :class:`FRect`.</desc>
    </attr>
    <attr name="width">
      <desc>Gets or sets the width of the :class:`FRect`.</desc>
    </attr>
    <attr name="x">
      <desc>Gets or sets the horizontal top left position of the
      :class:`FRect`.</desc>
    </attr>
    <attr name="y">
      <desc>Gets or sets the vertical top left position of the
      :class:`FRect`.</desc>
    </attr>
  </class>

  <class name="Rect">
    <constructor>Rect (...) -> Rect</constructor>
    <desc>A class for storing rectangular coordinates.

    A :class:`Rect` is used to store and manipulate rectangular
    coordinates.
    </desc>
    <attr name="bottom">
      <desc>Gets or sets the bottom edge position of the :class:`Rect`.</desc>
    </attr>
    <attr name="bottomleft">
      <desc>Gets or sets the bottom left corner position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="bottomright">
      <desc>Gets or sets the bottom right corner position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="center">
      <desc>Gets or sets the center position of the :class:`Rect`.</desc>
    </attr>
    <attr name="centerx">
      <desc>Gets or sets the horizontal center position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="centery">
      <desc>Gets or sets the vertical center position of the
      :class:`Rect`.</desc>
    </attr>
    <method name="clamp">
      <call>clamp (Rect) -> Rect</call>
      <desc>
        Moves the rectangle inside another.

        Returns a new rectangle that is moved to be completely inside
        the argument :class:`Rect`. If the rectangle is too large to fit inside,
        it is centered inside the argument :class:`Rect`, but its size is not
        changed.
      </desc>
    </method>
    <method name="clamp_ip">
      <call>clamp_ip (Rect) -> None</call>
      <desc>
        Moves the rectangle inside another, in place.

        Same as Rect.clamp(Rect), but operates in place.
      </desc>
    </method>
    <method name="clip">
      <call>clip (Rect) -> Rect</call>
      <desc>
        Crops a rectangle inside another.

        Returns a new rectangle that is cropped to be completely inside
        the argument :class:`Rect`. If the two rectangles do not overlap
        to begin with, a :class:`Rect` with 0 size is returned. Thus it
        returns the area, in which both rects overlap.
      </desc>
    </method>
    <method name="collidedict">
      <call>collidedict (dict[, checkvals, key]) -> key, value</call>
      <desc>
        Test if one rectangle in a dictionary intersects.

        Returns the key and value of the first dictionary value that
        collides with the :class:`Rect`. If no collisions are found,
        None is returned. Depending on the *checkvals* argument either the
        keys or values of the dict must be :class:`Rect` objects. By
        default, the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidedictall">
      <call>collidedictall (dict[, checkvals, key]) -> [(key, value), ...]</call>
      <desc>
        Test if all rectangles in a dictionary intersect.

        Returns a list of all the key and value pairs that intersect
        with the :class:`Rect`. If no collisions are found an empty list
        is returned. Depending on the *checkvals* argument either the keys
        or values of the dict must be :class:`Rect` objects. By default,
        the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelist">
      <call>collidelist (list[, key]) -> index</call>
      <desc>
        Test if one rectangle in a list intersects.

        Test whether the rectangle collides with any in a sequence of
        rectangles. The index of the first collision found is
        returned. If no collisions are found an index of -1 is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelistall">
      <call>collidelistall (list[, key]) -> [index, ...]</call>
      <desc>
        Test if all rectangles in a list intersect.

        Returns a list of all the indices that contain rectangles that
        collide with the :class:`Rect`. If no intersecting rectangles are found,
        an empty list is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two args, the
        :class:`FRect` itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidepoint">
      <call>collidepoint (x, y) -> bool</call>
      <desc>
        Test if a point is inside a rectangle.

        Returns true if the given point is inside the rectangle. A point
        along the right or bottom edge is not considered to be inside
        the rectangle.
      </desc>
    </method>
    <method name="colliderect">
      <call>colliderect (Rect) -> bool</call>
      <desc>
        Test if two rectangles overlap.

        Returns true if any portion of either rectangle overlap (except
        the top+bottom or left+right edges).
      </desc>
    </method>
    <method name="contains">
      <call>contains (Rect) -> bool</call>
      <desc>
        Test if one rectangle is inside another.

        Returns true when the argument rectangle is completely inside
        the :class:`Rect`.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Rect</call>
      <desc>
        Creates a copy of the :class:`Rect`.

        Returns a new :class:`Rect`, that contains the same values as the
        caller.
      </desc>
    </method>
    <method name="fit">
      <call>fit (Rect) -> Rect</call>
      <desc>
        Resize and move a rectangle with aspect ratio.

        Returns a new rectangle that is moved and resized to fit
        another. The aspect ratio of the original :class:`Rect` is preserved, so
        the new rectangle may be smaller than the target in either width
        or height.
      </desc>
    </method>
    <attr name="h">
      <desc>Gets or sets the height of the :class:`FRect`.</desc>
    </attr>
    <attr name="height">
      <desc>Gets or sets the height of the :class:`Rect`.</desc>
    </attr>
    <method name="inflate">
      <call>inflate (x, y) -> Rect</call>
      <desc>
        Grow or shrink the rectangle size.

        Returns a new rectangle with the size changed by the given
        offset. The rectangle remains centered around its current
        center. Negative values will shrink the rectangle.
      </desc>
    </method>
    <method name="inflate_ip">
      <call>inflate_ip (x, y) -> None</call>
      <desc>
        Grow or shrink the rectangle size, in place.

        Same as Rect.inflate(x, y), but operates in place.
      </desc>
    </method>
    <attr name="left">
      <desc>Gets or sets the left edge position of the :class:`Rect`.</desc>
    </attr>
    <attr name="midbottom">
      <desc>Gets or sets the mid bottom edge position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="midleft">
      <desc>Gets or sets the mid left edge position of the :class:`Rect`.</desc>
    </attr>
    <attr name="midright">
      <desc>Gets or sets the mid right edge position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="midtop">
      <desc>Gets or sets the mid top edge position of the
      :class:`Rect`.</desc>
    </attr>
    <method name="move">
      <call>move (x, y) -> Rect</call>
      <desc>
        Moves the rectangle.

        Returns a new rectangle that is moved by the given offset. The x
        and y arguments can be any integer value, positive or negative.
      </desc>
    </method>
    <method name="move_ip">
      <call>move_ip (x, y) -> None</call>
      <desc>
        Moves the rectangle, in place.

        Same as Rect.move (x, y), but operates in place.
      </desc>
    </method>
    <attr name="right">
      <desc>Gets or sets the right position of the :class:`Rect`.</desc>
    </attr>
    <attr name="size">
      <desc>Gets or sets the width and height of the :class:`Rect` as
      2-value tuple.</desc>
    </attr>
    <attr name="top">
      <desc>Gets or sets the top edge position of the :class:`Rect`.</desc>
    </attr>
    <attr name="topleft">
      <desc>Gets or sets the top left corner position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="topright">
      <desc>Gets or sets the top right corner position of the
      :class:`Rect`.</desc>
    </attr>
    <method name="union">
      <call>union (Rect) -> Rect</call>
      <desc>
        Joins two rectangles into one.

        Returns a new rectangle that completely covers the area of the
        two provided rectangles. There may be area inside the new :class:`Rect`
        that is not covered by the originals.
      </desc>
    </method>
    <method name="union_ip">
      <call>union_ip (Rect) -> Rect</call>
      <desc>
        Joins two rectangles into one, in place.

        Same as Rect.union(Rect), but operates in place.
      </desc>
    </method>
    <attr name="w">
      <desc>Gets or sets the width of the :class:`Rect`.</desc>
    </attr>
    <attr name="width">
      <desc>Gets or sets the width of the :class:`Rect`.</desc>
    </attr>
    <attr name="x">
      <desc>Gets or sets the horizontal top left position of the
      :class:`Rect`.</desc>
    </attr>
    <attr name="y">
      <desc>Gets or sets the vertical top left position of the
      :class:`Rect`.</desc>
    </attr>
  </class>

  <class name="Surface">
    <constructor>Surface () -> Surface</constructor>
    <desc>
      An abstract base class for arbitrary :class:`Surface` objects.
    
      You should not instantiate this class directly. 
    </desc>
    <method name="blit">
      <call>blit (**kwds) -> object</call>
      <desc>
        Performs a blit operation on the :class:`Surface`.

        The behaviour, arguments and return value depend on the concrete
        :class:`Surface` implementation.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Surface</call>
      <desc>Creates a copy of this :class:`Surface`.</desc>
    </method>
    <attr name="height">
      <desc>Gets the height of the :class:`Surface`.</desc>
    </attr>
    <attr name="pixels">
      <desc>Gets a buffer with the pixels of the :class:`Surface`.</desc>
    </attr>
    <attr name="size">
      <desc>Gets the width and height of the :class:`Surface`.</desc>
    </attr>
    <attr name="width">
      <desc>Gets the width of the :class:`Surface`.</desc>
    </attr>
  </class>

  <class name="Font">
    <constructor>Font () -> Font</constructor>
    <desc>
      An abstract base class for arbitrary :class:`Font` objects.
    
      You should not instantiate this class directly.
    </desc>
    <method name="render">
      <call>render (**kwds) -> object</call>
      <desc>
          Renders the specified text using the Font object. The exact input
          arguments and return value is dependand on each specific Font
          implementation.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Font</call>
      <desc>Creates a copy of this :class:`Font`.</desc>
    </method>
    <attr name="height">
      <desc>Gets the standard height of the :class:`Font` typography.</desc>
    </attr>
    <attr name="size">
      <desc>Gets the width and height of the :class:`Font` typography.</desc>
    </attr>
    <attr name="name">
      <desc>Gets the name of the loaded :class:`Font`.</desc>
    </attr>
    <attr name="style">
      <desc>Gets or sets the style used to render the :class:`Font`.</desc>
    </attr>
  </class>

</module>

