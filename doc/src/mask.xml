<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module [
<!ELEMENT module (desc, (func|class)*)>
<!ATTLIST module name CDATA #REQUIRED>
<!ELEMENT desc (#PCDATA)>
<!ELEMENT call (#PCDATA)>
<!ELEMENT func (call, desc)>
<!ATTLIST func name CDATA #REQUIRED>
<!ELEMENT class (constructor, desc, (attr|method)*)>
<!ATTLIST class name CDATA #REQUIRED>
<!ELEMENT constructor (#PCDATA)>
<!ELEMENT attr (#PCDATA)>
<!ATTLIST attr name CDATA #REQUIRED>
<!ELEMENT method (call, desc)>
<!ATTLIST method name CDATA #REQUIRED>
]>

<module name="pygame2.mask">
  <desc>
    A module for image masks, suitable for fast pixel-perfect collision
    detections.
  </desc>

  <class name="Mask">
    <constructor>Mask (width, height) -> Mask</constructor>
    <desc>Creates a new Mask object with the specified width and height</desc>
    <attr name="angle">
      Gets the orientation of the pixels. Finds the approximate orientation of
      the pixels in the image from -90 to 90 degrees. This works best if
      performed on one connected component of pixels. It will return 0.0 on an
      empty Mask.
    </attr>
    <attr name="centroid">
      Gets the centroid, the center of pixel mass, of the pixels in a Mask.
      Returns a coordinate tuple for the centroid of the Mask. if the Mask is
      empty, it will return (0,0).
    </attr>
    <method name="clear">
      <call>Mask.clear () -> None</call>
      <desc>
        Clears all bits in the Mask.

        Resets the state of all bits in the Mask to 0.
      </desc>
    </method>
    <method name="connected_component">
      <call>Mask.connected_component (x=None, y=None) -> Mask</call>
      <desc>
        Returns a Mask of a connected region of pixels.

        This uses the SAUF algorithm to find a connected component in
        the Mask. It checks 8 point connectivity. By default, it will
        return the largest connected component in the image. Optionally,
        a coordinate pair of a pixel can be specified, and the connected
        component containing it will be returned. In the event the pixel
        at that location is not set, the returned Mask will be
        empty. The Mask returned is the same size as the original Mask.
      </desc>
    </method>
    <method name="connected_components">
      <call>Mask.connected_component (x=None, y=None) -> Mask</call>
      <desc>
        Returns a Mask of a connected region of pixels.

        This uses the SAUF algorithm to find a connected component in
        the Mask. It checks 8 point connectivity. By default, it will
        return the largest connected component in the image. Optionally,
        a coordinate pair of a pixel can be specified, and the connected
        component containing it will be returned. In the event the pixel
        at that location is not set, the returned Mask will be
        empty. The Mask returned is the same size as the original Mask.
      </desc>
    </method>
    <attr name="count">Gets the amount of bits in the Mask.</attr>
    <method name="draw">
      <call>Mask.draw (mask, x, y) -> None</call>
      <desc>
        Draws the passed Mask onto the Mask.
        
        This performs a bitwise OR operation upon the calling Mask. The
        passed mask's start offset for the draw operation will be the x and
        y offset passed to the method.
      </desc>
    </method>
    <method name="erase">
      <call>Mask.erase (mask, x, y) -> None</call>
      <desc>
        Erases the passed Mask from the Mask.

        This performs a bitwise NAND operation upon the calling Mask. The
        passed mask's start offfset for the erase operation will be the x and
        y offset passed to the method.
      </desc>
    </method>
    <method name="fill">
      <call>Mask.fill () -> None</call>
      <desc>
        Sets all bits to 1 within the Mask.
      </desc>
    </method>
    <method name="get_at">
      <call>Mask.get_at (x, y) -> int</call>
      <desc>
        Gets the bit value at the desired location.
      </desc>
    </method>
    <method name="get_bounding_rects">
      <call>Mask.get_bounding_rects () -> [Mask, Mask ...]</call>
      <desc>
        Returns a list of bounding rects of regions of set pixels.

        This gets a bounding rect of connected regions of set bits. A bounding
        rect is one for which each of the connected pixels is inside the rect.
      </desc>
    </method>
    <attr name="height">Gets the height of the Mask.</attr>
    <method name="invert">
      <call>Mask.invert () -> None</call>
      <desc>
        Inverts all bits in the Mask.
      </desc>
    </method>
    <method name="outline">
      <call>TODO</call>
      <desc>TODO</desc>
    </method>
    <method name="overlap">
      <call>Mask.overlap (mask, x, y) -> int, int</call>
      <desc>
        Returns nonzero if the masks overlap with the given offset.

        The overlap tests uses the following offsets (which may be negative): ::

          +----+----------...
          |A   | yoffset
          |  +-+----------...
          +--|B
          |xoffset
          |  |
          |  |
          :  :
      </desc>
    </method>
    <method name="overlap_area">
      <call>Mask.overlap_area (mask, x, y) -> int</call>
      <desc>
        Returns the number of overlapping bits of two Masks.

        This returns how many pixels overlap with the other mask given. It
        can be used to see in which direction things collide, or to see how
        much the two masks collide.
      </desc>
    </method>
    <method name="overlap_mask">
      <call>Mask.overlap_mask (mask, x, y) -> Mask.</call>
      <desc>
        Returns a mask with the overlap of two other masks. A bitwise AND.
      </desc>
    </method>
    <method name="scale">
      <call>Mask.scale (width, height) -> Mask</call>
      <desc>
        Creates a new scaled Mask with the given width and height.

        The quality of the scaling may not be perfect for all circumstances,
        but it should be reasonable. If either w or h is 0 a clear 1x1 mask is
        returned.
      </desc>
    </method>
    <method name="set_at">
      <call>Mask.set_at (x, y) -> None</call>
      <desc>
        Sets the bit value at the desired location.
      </desc>
    </method>
    <attr name="size">Gets the width and height of the Mask as tuple.</attr>
    <attr name="width">Gets the width of the Mask</attr>
  </class>

  <func name="from_surface">
    <call>from_surface (surface, threshold) -> Mask</call>
    <desc>
      Returns a Mask from the given pygame2.sdl.video.Surface.

      Makes the transparent parts of the Surface not set, and the opaque parts
      set. The alpha of each pixel is checked to see if it is greater than the
      given threshold. If the Surface is color keyed, then threshold is not
      used.

      This requires pygame2 to be built with SDL support enabled.
    </desc>
  </func>
  <func name="from_threshold">
    <call>from_threshold () -> Mask</call>
    <desc>TODO</desc>
  </func>
</module>

