#!/usr/bin/env python

'''Interoperability test with PIL.

An SDL surface is created for each frame generated by PIL.
'''

__docformat__ = 'restructuredtext'
__version__ = '$Id$'

import math
import os
import sys

from SDL import *
import SDL.array
import Image

DEFAULT_IMAGE = os.path.join(os.path.dirname(sys.argv[0]), 'sample.bmp')

if __name__ == '__main__':
    SDL_Init(SDL_INIT_VIDEO)

    image_filename = DEFAULT_IMAGE
    if len(sys.argv) > 1:
        image_filename = sys.argv[1]

    src_image = Image.open(image_filename)
    size = int(math.sqrt(src_image.size[0]**2 + src_image.size[1]**2) + 0.5)
    original_image = Image.new('RGBA', (size, size))
    original_image.paste(src_image, ((size - src_image.size[0]) / 2, 
                                     (size - src_image.size[1]) / 2))

    screen = SDL_SetVideoMode(size, size, 32, 0)

    done = False
    angle = 0
    while not done:
        event = SDL_PollEventAndReturn()
        while event:
            if event.type in (SDL_QUIT, SDL_KEYDOWN):
                done = True
            event = SDL_PollEventAndReturn()

        angle = (angle + 1) % 360
        image = original_image.rotate(angle)
        image_width, image_height = image.size

        # Caution: keep the ctypes array ("data") as a local var during
        # blitting, otherwise the pixel data will be free'd early
        s = image.tostring()
        data = SDL.array.to_ctypes(s, len(s), c_ubyte)

        # This alternative also works
        #s = [c[0] | (c[1] << 8) | (c[2] << 16) for c in image.getdata()]
        #data = SDL.array.to_ctypes(s, len(s), c_uint)

        surface = SDL_CreateRGBSurfaceFrom(data,
            image_width, image_height, 32, image_width * 4,
            0x000000ff,
            0x0000ff00,
            0x00ff0000,
            0x00000000)
     
        SDL_BlitSurface(surface, None, screen, None)
        SDL_UpdateRect(screen, 0, 0, 0, 0)
        SDL_FreeSurface(surface)

    SDL_Quit()
